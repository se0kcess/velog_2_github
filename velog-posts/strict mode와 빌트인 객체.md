<p><img alt="" src="https://velog.velcdn.com/images/se0kcess/post/cf81daa9-a178-41a7-8c0d-5a11ace3e7d6/image.png" /></p>
<h3 id="암묵적-전역">암묵적 전역</h3>
<p>변수가 선언되지 않았음에도 자바스크립트 엔진에서 암묵적으로 전역 객체에 동적으로 프로퍼티를 동적으로 생성해 마치 전역 변수처럼 사용하는 것</p>
<h3 id="strict-mode">strict mode</h3>
<p>ES5부터 암묵적 전역으로 인해 발생하는 문제를 해결하기 위해 도입된 모드로, 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생하거나 최적화 작업에 문제를 일으킬 수 있는 코드에 명시적 에러를 발생시킴</p>
<h4 id="strict-mode-적용--함수-몸체에의-선두에-use-strict-추가">strict mode 적용 : 함수 몸체에의 선두에 'use strict' 추가</h4>
<p>전역의 선두에 위치 시 스크립트 전체에 strict mode 적용 (스크립트 단위)</p>
<h3 id="strict-mode가-발생시키는-에러">strict mode가 발생시키는 에러</h3>
<ul>
<li>Reference Error : 선언하지 않은 변수 참조 시</li>
<li>Syntax Error<ul>
<li>delete 연산자로 변수, 함수, 매개변수 삭제 시</li>
<li>중복된 매개변수 사용 시</li>
<li>with 문 사용 시</li>
</ul>
</li>
</ul>
<h3 id="strict-mode-적용에-의한-변화">strict mode 적용에 의한 변화</h3>
<ul>
<li>일반 함수의 this : strict mode에서 함수를 일반 함수로서 호출하면 this에 undefined 바인딩 됨</li>
<li>arguments 객체 : 매개변수에 전달된 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않음</li>
</ul>
<hr />
<h1 id="빌트인-객체">빌트인 객체</h1>
<h3 id="자바스크립트-객체의-분류">자바스크립트 객체의 분류</h3>
<ul>
<li><p>표준 빌트인 객체 : ECMAScript 사양에 정의된 객체, 애플리케이션 전역의 공통 기능을 제공함. 자바스크립트 실행 환경과 관계없이 언제나 사용 가능 / 전역 객체의 프로퍼티로서 제공되므로 별도의 선언 없이 전역 변수처럼 언제나 참조 가능</p>
</li>
<li><p>호스트 객체 : ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행환경에서 추가로 제공하는 객체</p>
</li>
<li><p>사용자 정의 객체 : 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말함</p>
</li>
</ul>
<h3 id="표준-빌트인-객체">표준 빌트인 객체</h3>
<ul>
<li>인스턴스를 생성할 수 있는 생성자 함수 객체 (Math, Reflect, JSON 제외)</li>
<li>생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드 제공</li>
</ul>
<h3 id="생성자-함수로-호출하여-인스턴스를-생성할-수-있음">생성자 함수로 호출하여 인스턴스를 생성할 수 있음</h3>
<ul>
<li>생성된 인스턴스의 프로토타입은 표준 빌트인 객체에 prototype 프로퍼티에 바인딩 된 객체 (ex: String 인스턴스의 프로토타입은 String.prototype)</li>
<li>바인딩된 객체는 다양한 기능의 빌트인 프로토타입 메서드를 제공함</li>
<li>인스턴스 없이도 호출 가능한 빌트인 정적 메서드를 제공함</li>
</ul>
<h3 id="원시-값과-래퍼-객체">원시 값과 래퍼 객체</h3>
<p>원시 값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌림 -&gt; 래퍼 객체</p>
<p><strong>래퍼 객체의 생성자함수 인스턴스는 프로토타입 메서드를 상속받아 사용 가능</strong>
래퍼 객체의 처리가 종룓되면 래퍼 객체의 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션 대상이 됨</p>
<blockquote>
<p>ES6에서 새롭게 도입된 원시값인 심벌도 래퍼 객체를 생성한다.
심벌은 일반적인 원시값과 달리 리터럴 표기법으로 생성할 수 없고 Symbol 함수를 통해 생성해야 하므로 다른 원시값과는 차이가 있다</p>
</blockquote>
<h3 id="전역-객체">전역 객체</h3>
<p>코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체</p>
<ul>
<li>브라우저 환경에서의 전역 객체 : window,self,this,frames</li>
<li>Node.js 환경 : global</li>
</ul>
<blockquote>
<p>전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.</p>
</blockquote>
<p><strong>전역 객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체이다.</strong>
전역 객체 자신은 어떤 객체의 프로퍼티도 아니며 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다.</p>
<h3 id="전역-객체의-특징">전역 객체의 특징</h3>
<ul>
<li>전역 객체는 개발자가 의도적으로 생성할 수 없다. 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.</li>
<li>전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.</li>
<li>전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 갖고 있다.</li>
<li>자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.<ul>
<li>브라우저 환경 : 클라이언트 사이드 Web API</li>
<li>Node.js 환경 : Node.js 고유 API</li>
</ul>
</li>
<li>var 키워드로 선언한 전역 변수와 선언하지 않은 전역 변수에 값을 할당한 암묵적 전역, 전역 함수는 전역 객체의 프로퍼티가 된다.</li>
<li>let, const로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. / 보이지 않는 개념적인 블록 내에 존재</li>
<li>브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다.</li>
</ul>
<h3 id="전역-객체의-프로퍼티와-메서드">전역 객체의 프로퍼티와 메서드</h3>
<ul>
<li><strong>빌트인 프로퍼티</strong> : 전역 객체의 프로퍼티, 애플리케이션 전역에서 사용하는 값<ul>
<li>Infinity : 무한대를 나타내는 숫자값 Infinity를 가짐</li>
<li>NaN : NaN 프로퍼티는 숫자가 아님을 나타내는 숫자값 NaN을 가짐</li>
<li>undefined : 원시 타입 undefined를 값으로 가짐</li>
</ul>
</li>
</ul>
<ul>
<li><strong>빌트인 전역 함수</strong> : 전역에서 호출 가능한 빌트인 함수로서 전역 객체의 메서드<ul>
<li>eval : 주어진 문자열 코드를 런타임에 동적으로 평가 또는 실행 / strict mode에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성</li>
<li>isFinite : 전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환하고, 무한수이면 false 반환 / 전달받은 인수의 타입이 숫자가 아닌 경우 숫자로 타입을 변환한 후 검사 수행</li>
<li>isNaN : 전달받은 인수가 NaN 인지 검사하여 그 결과를 불리언 타입으로 반환 / 숫자가 아닌 경우 숫자로 타입을 변환한 후 검사 수행</li>
<li>parseFloat : 전달받은 문자열 인수를 정수로 해석하여 반환 / 문자열이 아니면 문자열로 변환한 다음 정수로 해석하여 반환</li>
<li>encodeURI : 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩</li>
<li>decodeURI : 인코딩 된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩</li>
</ul>
</li>
</ul>